uint16_t count=0;
inline void create_sawtooth(int32_t &cVout, uint16_t &count, int32_t vout_arr[], int32_t phase_arr[], uint8_t keyint_0, uint8_t keyint_1, int8_t octave){
  for(int i=0; i<8;i++){
    if((keyint_0 & (1<<i)) != 0){ 
      count++;
      if(knob2.knobrotation + octave > 4){
        phase_arr[i] += stepSizes[i] << (knob2.knobrotation - 4 + octave);
      }
      else{
        phase_arr[i] += stepSizes[i] >> (-octave + 4 - knob2.knobrotation);
      }
      vout_arr[i] = (phase_arr[i] >> 24); 
      vout_arr[i] = vout_arr[i] >> (8 - knob3.knobrotation);
      cVout += vout_arr[i];
    }
  }
  for(int i=0; i<4;i++){
    if((keyint_1 & (1<<i)) != 0){
      count++;
      if(knob2.knobrotation + octave > 4){
        phase_arr[i+8] += stepSizes[i+8] << (knob2.knobrotation - 4 + octave);
      }
      else{
        phase_arr[i+8] += stepSizes[i+8] >> (-octave + 4 - knob2.knobrotation);
      }
      vout_arr[i+8] = (phase_arr[i+8] >> 24); 
      vout_arr[i+8] = vout_arr[i+8] >> (8 - knob3.knobrotation);
      cVout += vout_arr[i+8];
    }
  }
}

void sampleISR() {
  count=0;
  static int32_t phaseAccLO[12] = {0};
  static int32_t phaseAccUO[12] = {0};
  static int32_t phaseAccR[12] = {0};
  int32_t cVout = 0;
  int32_t RVout[12] = {0};
  int32_t LVout[12] = {0};
  int32_t UVout[12] = {0};
  create_signal(cVout, count, LVout, phaseAccLO, loctave_1, loctave_2, -1);
  create_signal(cVout, count, UVout, phaseAccUO, uoctave_1, uoctave_2, 1);
  create_signal(cVout, count, RVout, phaseAccR, g_keys_pressed_p1, g_keys_pressed_p2, 0);
  cVout = max(-128, min(127, (int)(cVout/count)));
  frund = cVout;
  analogWrite(OUTR_PIN, (cVout + 128));