void sampleISR() {
  count=0;
  static int32_t phaseAccS[36] = {0};
  static int32_t phaseAccR[12] = {0};
  int32_t cVout = 0;
    for(int i=0; i<8;i++){
    if((loctave_1 & (1<<i)) != 0){
      count++; 
      if(knob2.knobrotation > 4){
        phaseAccS[i] += stepSizes[i] << (knob2.knobrotation - 4);
      }
      else{
        phaseAccS[i] += stepSizes[i] >> (1 + 4 - knob2.knobrotation);
      }
      Vout[i] = (phaseAccS[i] >> 24); 
      Vout[i] = Vout[i] >> (8 - knob3.knobrotation);
      cVout += Vout[i];
    }
  }
  for(int i=0; i<4;i++){
    if((loctave_2 & (1<<i)) != 0){ 
      count++;
      if(knob2.knobrotation > 4){
        phaseAccS[i+8] += stepSizes[i+8] << (knob2.knobrotation - 4);
      }
      else{
        phaseAccS[i+8] += stepSizes[i+8] >> (4 - knob2.knobrotation);
      }
      Vout[i+8] = (phaseAccS[i+8] >> 24); 
      Vout[i+8] = Vout[i+8] >> (8 - knob3.knobrotation);
      cVout += Vout[i+8];
    }
  }

  for(int i=0; i<8;i++){
    if((uoctave_1 & (1<<i)) != 0){ 
      count++;
      if(knob2.knobrotation > 4){
        phaseAccS[i] += stepSizes[i] << (knob2.knobrotation - 4);
      }
      else{
        phaseAccS[i] += stepSizes[i] >> (4 - knob2.knobrotation);
      }
      Vout[i] = (phaseAccS[i] >> 24); 
      Vout[i] = Vout[i] >> (8 - knob3.knobrotation);
      cVout += Vout[i];
    }
  }

  for(int i=0; i<4;i++){
    if((uoctave_2 & (1<<i)) != 0){
      count++;
      if(knob2.knobrotation > 4){
        phaseAccS[i+8] += stepSizes[i+8] << (knob2.knobrotation - 4);
      }
      else{
        phaseAccS[i+8] += stepSizes[i+8] >> (4 - knob2.knobrotation);
      }
      Vout[i+8] = (phaseAccS[i+8] >> 24); 
      Vout[i+8] = Vout[i+8] >> (8 - knob3.knobrotation);
      cVout += Vout[i+8];
    }
  }


  for(int i=0; i<8;i++){
    if((g_keys_pressed_p1 & (1<<i)) != 0){ 
      count++;
      if(knob2.knobrotation > 4){
        phaseAccR[i] += stepSizes[i] << (knob2.knobrotation - 4);
      }
      else{
        phaseAccR[i] += stepSizes[i] >> (4 - knob2.knobrotation);
      }
      Vout[i] = (phaseAccR[i] >> 24); 
      Vout[i] = Vout[i] >> (8 - knob3.knobrotation);
      cVout += Vout[i];
    }
  }

  for(int i=0; i<4;i++){
    if((g_keys_pressed_p2 & (1<<i)) != 0){ 
      count++;
      if(knob2.knobrotation > 4){
        phaseAccR[i+8] += stepSizes[i+8] << (knob2.knobrotation - 4);
      }
      else{
        phaseAccR[i+8] += stepSizes[i+8] >> (4 - knob2.knobrotation);
      }
      Vout[i+8] = (phaseAccR[i+8] >> 24); 
      Vout[i+8] = Vout[i+8] >> (8 - knob3.knobrotation);
      cVout += Vout[i+8];
    }
  }

  cVout = max(-128, min(127, (int)(cVout/count)));
  frund = cVout;
  analogWrite(OUTR_PIN, (cVout + 128));
}